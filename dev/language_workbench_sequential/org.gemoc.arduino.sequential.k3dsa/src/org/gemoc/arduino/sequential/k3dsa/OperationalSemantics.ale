behavior org.gemoc.arduino.sequential.dsa;

use org.gemoc.arduino.sequential.k3dsa.JavaServices;
use org.gemoc.arduino.sequential.xardunio.design.services.ArduinoServices;

open class arduino.Instruction {
	def Project getProject (Module module) {
		Project project := null;
		
		EObject current := self.eContainer();
		while (current != null) {
			if(current.oclIsKindOf(arduino::Project)) {
				project := current;
			}
			current := current.eContainer();
		}
		
		result := project;
	}
	
	def Pin getPin(Module module) {
		Pin pin := null;
		Project project := self.getProject(module);
		
		for(board in project.boards) {
			if(board != null and board.oclIsKindOf(arduino::ArduinoBorad)) {
				ArduinoBoard arduinoBoard := board;
				for (analogPin in arduinoBoard.analogPins) {
					if (analogPin.module = module) {
						pin := analogPin;
					}
				}
				for (digitalPin in arduinoBoard.digitalPins) {
					if (digitalPin.module = module) {
						pin := digitalPin;
					}
				}
			}
		}
		
		result := pin;
	}
	
	def void execute() {
	}
	
	def void finalize() {
	}
}

open class arduino.Project {
	
	def void execute() {
		('DEBUG: exec').log();
		Sequence(arduino::Sketch) sketches := self.sketches;
		('DEBUG: '+sketches).log();
		while(true) {
			for(s in sketches) {
				s.block.execute();
			}
		}
	}
	
	@main
	def void main() {
		'DEBUG: main'.log();
		Integer start := self.getTime();
		('DEBUG: '+start).log();
		self.execute();
		Integer stop := self.getTime();
		('time to execute ' + (stop - start)).log();
	}
	
	@step
	def void setup() {
		('DEBUG: SETUP').log();
		
		for(o in self.eAllContents()) {
			if(o.oclIsKindOf(arduino::IntegerVariable)) {
				o.value := o.initialValue;
				('DEBUG: SETUP '+o).log();
				('DEBUG: SETUP intVal '+o.value).log();
			}
			else {
				if(o.oclIsKindOf(arduino::BooleanVariable)) {
					o.value := o.initialValue;
					('DEBUG: SETUP '+o).log();
					('DEBUG: SETUP boolVal '+o.value).log();
				}
				else {
					if (o.oclIsKindOf(arduino::Pin)) {
						o.level := 0;
						('DEBUG: SETUP '+o).log();
						('DEBUG: SETUP lvl '+o.level).log();
					}
				}
			}
		}
	}
	
	@init
	def void initializeModel(Sequence(String) args){
		self.setup();
	}
}

open class arduino.VariableAssignment {
	@step
	def void execute() {
		Variable variable := self.variable;
		if (variable.oclIsKindOf(arduino::IntegerVariable)){
			('DEBUG: Assign '+self).log();
			('DEBUG: Assign op '+self.operand).log();
			('DEBUG: Assign op  val '+self.operand.evaluate()).log();
			variable.value := self.operand.evaluate();
			('DEBUG: Assign var  val '+variable.value).log();
		}
		if (variable.oclIsKindOf(arduino::BooleanVariable)){
			variable.value := self.operand.evaluate();
		}
	}
}

open class arduino.Block {
	def void execute() {
		for (i in self.instructions) {
			i.execute();
		}
	}
}

open class arduino.ModuleInstruction {
	def void execute() {
	}
}

open class arduino.ModuleAssignment {
	@step
	def void execute() {
		('DEBUG: ModuleAssign '+self).log();
		Pin pin := self.module.getPin();
		('DEBUG: pin  '+pin).log();
		if (self.operand.oclIsKindOf(arduino::IntegerExpression)){
			pin.level := self.operand.evaluate();
			('DEBUG: pinlvl  '+self.operand.evaluate()).log();
		}
		if (self.operand.oclIsKindOf(arduino::BooleanExpression)){
			if (self.operand.evaluate()){
				pin.level := 1023; //HIGH
			} else {
				pin.level := 0; //LOW
			}
		}
		
		//FIXME Here it is dirty but I think we should 'transmit' the value in the module itself as the wire should do in true life
		if (self.module.oclIsKindOf(arduino::BluetoothTransceiver)){
			self.module.dataToSend.add(pin.level);
			//FIXME temporary solution
			self.module.push();
		}
	}
}

open class arduino.ArduinoCommunicationModule {
	def void push() {}
}

open class arduino.BluetoothTransceiver {
	Sequence(Integer) dataToSend;
	Sequence(Integer) dataReceived;
	
	@step
	def void push(){
		for(t in self.connectedTransceiver) {
			Sequence(Integer) l := t.dataReceived;
			for(i in self.dataToSend) {
				l.add(i);
			}
		}
		self.dataToSend := Sequence{};
	}
}

open class arduino.VariableDeclaration {
	@step
	def void execute() {
		if(self.variable.oclIsKindOf(arduino::IntergerVariable)) {
			self.variable.value := self.variable.initialValue;
		}
		if(self.variable.oclIsKindOf(arduino::BooleanVariable)) {
			self.variable.value := self.variable.initialValue;
		}
	}
}

open class arduino.Control {
	def void execute() {
	}
	def Boolean evaluate() {
	}
}

open class arduino.If {
	def Boolean evaluate() {
		Boolean resCond := false;
		if (self.condition.oclIsKindOf(arduino::BooleanExpression)){
			resCond := self.condition.evaluate();
		}
		result := resCond;
	}
	
	@step
	def void execute() {
		if (self.evaluate()) {
			self.block.execute();
		} else {
			if (self.elseBlock != null) {
				self.elseBlock.execute();
			}
		}
	}
}

open class arduino.Repeat {
	Integer i := 0;

	def Boolean evaluate() {
		Boolean resCond := false;
		resCond := (self.i  < self.iteration);
		self.i := self.i+1;
		result := resCond;
	}

	def void finalize() {
		self.i := 0;
	}
	
	@step
	def void execute() {
		while (self.evaluate()) {
			self.block.execute();
		}
		self.finalize();
	}
}

open class arduino.While {
	def Boolean evaluate() {
		Boolean resCond := self.condition.evaluate();
		result := resCond;
	}
	def void execute() {
		while (self.evaluate()) {
			self.block.execute();
		}
	}
}

open class arduino.Utilities {
	def void execute() {
	}
}

open class arduino.BinaryIntegerExpression {
	def Object evaluate() {
		('DEBUG: BinaryExp '+self).log();
		Integer iLeft := 0;
		iLeft := self.left.evaluate();
		
		Integer iRight := 0;
		iRight := self.right.evaluate();
		
		result :=
			switch (self.operator) {
				case (arduino::BinaryIntegerOperatorKind::div) : iLeft / iRight
				case (arduino::BinaryIntegerOperatorKind::max) : iLeft.max(iRight)
				case (arduino::BinaryIntegerOperatorKind::min) : iLeft.min(iRight)
				case (arduino::BinaryIntegerOperatorKind::minus) : iLeft - iRight
				case (arduino::BinaryIntegerOperatorKind::mul) : iLeft * iRight
				case (arduino::BinaryIntegerOperatorKind::plus) : iLeft + iRight
				case (arduino::BinaryIntegerOperatorKind::pourcent) : iLeft.mod(iRight)
				default: 0
			};
		
		('DEBUG: BinaryExp left '+self.left).log();
		('DEBUG: BinaryExp left '+iLeft).log();
		('DEBUG: BinaryExp right '+self.right).log();
		('DEBUG: BinaryExp right '+iRight).log();
		('DEBUG: BinaryExp op '+self.operator).log();
		('DEBUG: BinaryExp res '+result).log();
	}
}

open class arduino.BooleanModuleGet {
	def Object evaluate() {
		Pin pin := self.instruction.getPin(self.module);
		if (pin.level = 0){
			result := false;
		}
		else {
			result := true;
		}
	}
}

open class arduino.BooleanConstant {
	def Object evaluate() {
		result := self.value;
	}
}

open class arduino.IntegerConstant {
	def Object evaluate() {
		result := self.value;
	}
}

open class arduino.IntegerModuleGet {
	def Object evaluate() {
		
		//FIXME Here it is dirty but I think we should 'transmit' the value in the module itself as the wire should do in true life
		if (self.module.oclIsKindOf(arduino::BluetoothTransceiver)){
			Sequence(Integer) l := self.module.dataReceived;
			Integer res := l->first();
			if (res != null) {
				l.remove(0);
				result := res;
			} else {
				result := 0;
			}
		}
		else {
			Pin pin := self.instruction.getPin(self.module);
			result := pin.level;
		}
	}
}

open class arduino.BinaryBooleanExpression {
	def Object evaluate() {
		Boolean leftIsBoolean := false;
		Boolean rightIsBoolean := false;
		Boolean bLeft := false;
		Integer iLeft := 0;
		if(self.left.oclIsKindOf(arduino::BooleanExpression)) {
			bLeft := self.left.evaluate();
			leftIsBoolean := true;
		}
		if(self.left.oclIsKindOf(arduino::IntegerExpression)) {
			iLeft := self.left.evaluate();
		}
		
		Boolean bRight := false;
		Boolean iRight := 0;
		if(self.right.oclIsKindOf(arduino::BooleanExpression)) {
			bRight := self.right.evaluate();
			rightIsBoolean := true;
		}
		if(self.right.oclIsKindOf(arduino::IntegerExpression)) {
			iRight := self.right.evaluate();
		}
		result := switch(self.operator) {
			case ('and'/*arduino::BinaryBooleanOperatorKind::and*/) :
				if bLeft then
					bRight
				else 
					Boolean.FALSE
				endif
			case ('or'/*arduino::BinaryBooleanOperatorKind::or*/) :
				if bLeft then
					Boolean.TRUE
				else 
					bRight
				endif
			case (arduino::BinaryBooleanOperatorKind::Different) : not(bLeft.equals(bRight))
			case (arduino::BinaryBooleanOperatorKind::equal) :
				if leftIsBoolean then
					bLeft.equals(bRight)
				else 
					iLeft.equals(iRight)
				endif
			case (arduino::BinaryBooleanOperatorKind::inf) : iLeft < iRight
			case (arduino::BinaryBooleanOperatorKind::infOrEqual) : iLeft <= iRight
			case (arduino::BinaryBooleanOperatorKind::sup) : iLeft > iRight
			case (arduino::BinaryBooleanOperatorKind::supOrEqual) : iLeft >= iRight
			default : 0
			};
	}
}

open class arduino.Constant {
	def Object evaluate() {
		if(self.oclIsKindOf(arduino::BooleanConstant)) {
			result := self.value;
		}
		if(self.oclIsKindOf(arduino::IntegerConstant)) {
			result := self.value;
		}
	}
}

open class arduino.Delay {
	@step
	def void execute() {
		self.value.sleep();
	}
}

open class arduino.Pin {
	Integer level;
}

open class arduino.Variable {
	def Object evaluate() {
		
	}
}

open class arduino.IntegerVariable {
	Integer value;
	
	def Object evaluate(){
		('DEBUG: IntVar '+self).log();
		result := self.value;
		('DEBUG: IntVar res '+result).log();
	}
}

open class arduino.BooleanVariable {
	Boolean value;
	
	def Object evaluate(){
		result := self.value;
	}
}

open class arduino.VariableRef {
	def Object evaluate(){
		if(self.oclIsKindOf(arduino::BooleanVariableRef)) {
			result := self.variable.evaluate();
		}
		if(self.oclIsKindOf(arduino::IntegerVariableRef)) {
			result := self.variable.evaluate();
		}
	}
	
	def String computeDynamicLabel() {
		result := '';
		if (self.oclIsKindOf(arduino::BooleanVariableRef)) {
			BooleanVariable variable := self.variable;
			if (variable.value != null) {
				result := variable.name + '(=' + variable.value + ')';
			}
			else {
				result := variable.name;
			}
			('DEBUG: LABEL bool '+result).log();
		}
		if (self.oclIsKindOf(arduino::IntegerVariableRef)) {
			IntegerVariable variable := self.variable;
			if (variable.value != null) {
				result := variable.name + '(=' + variable.value + ')';
			}
			else {
				result := variable.name;
			}
			('DEBUG: LABEL int '+result).log();
		}
	}
}

open class arduino.Expression {
	def Instruction getInstruction() {
		Instruction instruction := null;

		EObject current := self.eContainer();
		while (current != null) {
			if (current.oclIsKindOf(arduino::Instruction)) {
				instruction := current;
				result := instruction;
			}
			current := current.eContainer();
		}
		
		result := instruction;
	}
	
	def Object evaluate() {
		
	}
}

open class arduino.LED {
	def String getImage() {
		Integer level := self.getPin().level;
//		('DEBUG: LED '+ self).log();
//		('DEBUG: LED pin '+ self.getPin()).log();
//		('DEBUG: LED lvl '+ self.getPin().level).log();
//		('DEBUG: LED color '+ self.color).log();
		if (level != null and level > 0) {
			result :=
				switch (self.color) {
					case (arduino::Color::blue) : '/org.gemoc.arduino.sequential.xarduino.design/images/dfrobot/blue_led_1023.jpg'
					case (arduino::Color::red) : '/org.gemoc.arduino.sequential.xarduino.design/images/dfrobot/red_led_1023.jpg'
					case (arduino::Color::white) : '/org.gemoc.arduino.sequential.xarduino.design/images/dfrobot/white_led_1023.jpg'
					default : '/org.gemoc.arduino.sequential.xarduino.design/images/default.svg'
				};
		}
		else {
			result :=
				switch (self.color) {
					case (arduino::Color::blue) : '/org.gemoc.arduino.sequential.xarduino.design/images/dfrobot/blue_led.jpg'
					case (arduino::Color::red) : '/org.gemoc.arduino.sequential.xarduino.design/images/dfrobot/red_led.jpg'
					case (arduino::Color::white) : '/org.gemoc.arduino.sequential.xarduino.design/images/dfrobot/white_led.jpg'
					default : '/org.gemoc.arduino.sequential.xarduino.design/images/default.svg'
				};
		}
//		('DEBUG: LED'+ result).log();
//		result := '/org.gemoc.arduino.sequential.xarduino.design/images/default.svg';
	}
}

open class arduino.Module {
	
	def Project getProject() {
		Project project := null;
		
		EObject current := self.eContainer();
		while (current != null) {
			if(current.oclIsKindOf(arduino::Project)) {
				project := current;
			}
			current := current.eContainer();
		}
		
		result := project;
	}
	
	def Pin getPin() {
		Pin pin := null;
		Project project := self.getProject();
		
		for(board in project.boards) {
			if(board != null and board.oclIsKindOf(arduino::ArduinoBoard)) {
				ArduinoBoard arduinoBoard := board;
				for (analogPin in arduinoBoard.analogPins) {
					if (analogPin.module = self) {
						pin := analogPin;
					}
				}
				for (digitalPin in arduinoBoard.digitalPins) {
					if (digitalPin.module = self) {
						pin := digitalPin;
					}
				}
			}
		}
		
		result := pin;
	}
}
